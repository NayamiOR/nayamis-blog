# 01 背包之：从递归到迭代

> Tips：因为要保证彻底理解防止和稀泥（防自己），所以可能全篇大白话加废话。

## 1. 问题描述

[494. 目标和](https://leetcode.cn/problems/target-sum/description/)

这道题首先要用数论处理一下，然后我们会得到一个：“刚好等于”型的 01 背包问题，要我们求方案数。

## 2. 递归解法

```go
func findTargetSumWays(nums []int, target int) int {
    sum := 0
    for _, value := range nums {
        sum += value
    }
    n := len(nums)
    target += sum
    if target < 0 || target%2 == 1 {
        return 0
    }
    target /= 2
    var dfs func(int, int) int
    dfs = func(i int, temp int) int {
        if i < 0 {
            if temp == 0 {
                return 1
            } else {
                return 0
            }
        }
        if nums[i] > temp {
            return dfs(i-1, temp)
        }
        return dfs(i-1, temp-nums[i]) + dfs(i-1, temp)
    }
    return dfs(n-1, target)
}
```

具体解题过程请看[灵神的动态规划视频](https://www.bilibili.com/video/BV16Y411v7Y6?vd_source=ee5f5f62deebaad2520d5495cba1bc3f)，或者下面的第三部分中也有提到状态的定义和转移。

## 3. 动态规划：如何把递归改成用数组迭代

### 状态定义

在这个经典的 01 背包问题里，递归函数有两个参数，一个是很好理解的索引，表示目前遍历到数组里的第几个数。另外一个参数表示的是当前的状态，准确来说就是计算到这的时候和 target 的差距，我们就管它叫状态。递归函数有一个返回值，表示的是遍历到这里的方案数，也就是结果。

回顾一下斐波那契动态规划，比如斐波那契数列本身，运算的过程中只会记录索引，还有结果的数字，总共两个量。

斐波那契数列的过程中只涉及两个量，而 01 背包涉及到了三个量。斐波那契数列计算的时候用一个一维数组就可以（不考虑优化情况），所以同理，我们这个 01 背包问题只要用一个二维数组即可。

这个二维数组有三个维度，外层数组索引用来表示遍历的索引，就是当前迭代到第几个数字，存储空间用来存放方案数，而多出来的内层数组索引这个维度就可以用来表示状态，也就是和 target 的差距。

对比一下递归函数和斐波那契数列，可以证明这三个维度的规划是合理的：数组的存储空间存放的永远是递归返回值、永远是这道题的最终答案。迭代的进度永远都是用数组的一条索引来表示。多出来的状态值迭代进度一样存在迭代函数的参数里，所以同用索引表示。

从数值的规模来看，迭代进度用索引表示肯定是合理的，而状态和方案两个值中，方案数可能会非常大，状态虽然可能也很大，但是增长速度比方案数慢很多，而且题目给的数据来看状态的范围都不会特别大，所以表达能力最强的存储空间维度肯定用来表示方案数，也就是结果。

### 状态转移

有了二维数组了以后，01 背包的状态转移思路和很多动态规划题型，比如斐波那契、爬楼梯、打家劫舍等都有一个很大的相同之处。迭代的过程中，当前遍历到的单元的结果都会从上一层或者前几层中对应的单元转移而来（废话）。

说得再事无巨细一点，列举如下：

- 斐波那契数列中，当前数字永远从前两个数字转移过来。
- 打家劫舍中，当前数字永远从上一个房子以外的其它房子转移而来。
- 爬楼梯中，到达当前楼梯的方案肯定从上一节和上上节楼梯转移而来（题目规定一次能跳一或两格）。

那么在这道题中状态怎么转移呢？

首先最简单的是索引维度（遍历到第几个数字），这一层中数据肯定是从上一层里转移来的（01 背包中要挨个遍历物体）。然后确认状态有几种转移的方法：01 背包有两种操作，选，或者不选。所以是两种转移的方法，说明当前单元有两种方法从上层转移而来。一种是没有选当前遍历到的数，一个是选了当前遍历的数。

用具体的例子直观理解：比如当前遍历到 `[8][30]`，说明遍历到第 8 个数（不重要），现在要求的就是截止到遍历到第 8 个数，能凑出 30 的方案数。假设物品中第 8 个数是 5，根据两种转移方法来判断，现在可能有两种情况，要么不选第 8 个数，方案数就是前 7 个数能凑出 30 的方案数；要么选第 8 个数以后能凑出 30 的方案数，第 8 个数是 5 说明前 7 个数凑出了 25，所以方案数就是前 7 个数凑出 25 的方案数。这两种方法都能凑出 30，所以遍历到第 8 个数能凑到 30 的方案数就是两种方法的方案数之和（不选第 8 个，前 7 个数凑出 30，以及选第 8 个，前 7 个数凑出 25 的方案数）。

那这里就可以写出状态转移方程：

$$
\begin{align}
dp[i][j]&=dp[i-1][j]\\
&\ +dp[i-1][j-nums[i]]
\end{align}\ \ \ \ \ \ \ \ \
(j\geq nums[i])
$$

$$
\begin{align}
dp[i][j]&=dp[i-1][j]
\end{align}\ \ \ \ \ \ \ \
(j\lt nums[i])
$$

值得注意的是这里要分类讨论一下，如果当前遍历到的数字大于当前求方案数的状态，那么排除选取当前数字这种可能。具体来说就是如果你遍历到了 20，但你现在求的是凑出 15 的方案数，因为状态都是非负的，所以肯定不可能选择这个 20。

### 代码实现

```cpp
class Solution {
   public:
    int findTargetSumWays(vector<int>& nums, int target) {
        long long sum = accumulate(nums.begin(), nums.end(), 0);
        int n = nums.size();
        target += sum;
        if (target < 0 || target % 2 == 1)
            return 0;
        target /= 2;

        vector<vector<int>> dp(n + 1, vector<int>(target + 1));
        dp[0][0] = 1;
        for (int i = 1; i < n + 1; i++) {
            for (int j = 0; j < target + 1; j++) {
                dp[i][j] += dp[i - 1][j];
                if (nums[i - 1] <= j) {
                    dp[i][j] += dp[i - 1][j - nums[i - 1]];
                }
            }
        }
        return dp[n][target];
    }
};
```

代码部分要注意的是二维数组的两个维度都要比 nums 的大小和 target 大 1，这样外层可以给表示“选 0 个数字”，内层可以给表示“状态目前为 0”两种情况腾出位置。

要注意的是这里的状态不是离 target 的数量，而是从 0 开始正向增加到的数值。

初始状态中只需要定义第 0 行，也就是什么都不选的情况。因为什么都不选的时候只会对 0 这个状态有一个方案数为 1，所以只需要赋值 `dp[0][0] = 1` 就够。

## 4. 数组空间优化

因为这段代码中，其实每次只用了上一层的索引（`[i-1]`），所以就像斐波那契数列中可以优化到只剩两个变量，这里我们可以把它优化成只用两个数组（可能可以继续优化，我没试过），如下。

```cpp
class Solution {
   public:
    int findTargetSumWays(vector<int>& nums, int target) {
        long long sum = accumulate(nums.begin(), nums.end(), 0);
        int n = nums.size();
        target += sum;
        if (target < 0 || target % 2 == 1)
            return 0;
        target /= 2;

        // vector<vector<int>> dp(n + 1, vector<int>(target + 1));
        vector<int> dp(target + 1);
        vector<int> temp(target + 1);
        dp[0] = 1;
        for (int i = 1; i < n + 1; i++) {
            fill(temp.begin(), temp.end(), 0);
            for (int j = 0; j < target + 1; j++) {
                temp[j] += dp[j];
                if (nums[i - 1] <= j) {
                    temp[j] += dp[j - nums[i - 1]];
                }
            }
            dp = temp;
        }
        return dp[target];
    }
};
```

上面代码中被注释掉的就是原来对二维数组的定义，改为了使用两个数组反复传递。这么修改以后，根据力扣上的运行数据，大约节省了 20%的内存开销，同时时间开销相比二维数组的方法打折了一半（细节原因不明确，可以评论补充）。
