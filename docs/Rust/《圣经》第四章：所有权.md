# 所有权

## 堆和栈上的数据

所有存储在栈上的数据必须拥有一个已知且固定的大小。

编译期无法确定大小的数据只能存储在堆中。

### 堆分配

堆的空间管理比较松散，需要的时候你可以直接请求特定大小空间，系统。系统会根据请求给你一块够大的可用空间并标记为已使用，然后给你这块空间地址的指针。这叫做堆分配。

将值压入栈中不叫分配。

---

因为要用指针跳转所以堆上的数据会比栈上的数据调用更慢，指令在内存中跳转次数越多性能越差（原因是缓存）。同样，在操作排布紧密的数据时会更有效率。

而且堆分配本身也会占用一些时钟周期。

## 用String类型说明移动

String是一个引用类型，String变量本身存储着一个指针。

把引用类型赋值给一个变量就会按传递指针的方式进行。

******引用类型会被移动是用来防止内存的重复释放：******

比如有个字符串s1，赋值给字符串s2，按照以往的逻辑，s1和s2应该指向同一块内存。

根据Rust会在离开作用域时释放内存，可知：

s1和s2在离开作用域时会分别释放一次内存，所以它们指向的同一块内存会被释放两遍。

这是我们要避免的，所以实际情况是，s1赋值给s2以后，它本身会被移动（失效）。

**********************************************************************************************************************************************************************************************这里说明的另一个Rust设计原则：Rust永远不会自动创建数据的深度拷贝，所以任何自动赋值都可以被认为是高效的**********************************************************************************************************************************************************************************************

而如果你想把s1的值赋值给s2，你可以用`.clone()`方法进行深度拷贝：

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
```

而这种规则对值类型是没用的，因为可以在编译时确定大小，可以存储在栈中。而且对于这些值的复制操作非常快，不用考虑性能。

## Copy trait

Copy trait 可以被用在整数这类完全存储在栈中的数据类型，实现这个trait可以让变量在赋值给其它变量之后仍然可用。

如果实现了Drop trait，那就不允许实现Copy trait。

一般来说任何简单标量的组合类型都可以Copy，任何要分配内存或者其它资源的类型都不会Copy。Rust规定，对于自定义类型，只有所有的成员都实现了 Copy trait，这个类型才有资格实现 Copy trait。

> 我们可以认为，Rust中只有 [POD](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Passive_data_structure)(C++语言中的Plain Old Data) 类型才有资格实现Copy trait。在Rust中，如果一个类型只包含POD数据类型的成员，没有指针类型的成员，并且没有自定义析构函数（实现Drop trait），那它就是POD类型。比如整数、浮点数、只包含POD类型的数组等，都属于POD类型。而Box、 String、 Vec等，不能按 bit 位拷贝的类型，都不属于POD类型。
> 

## 所有权和函数

将值传递给函数在语义上类似于赋值，所以变量传递给函数也会触发移动或者复制。

可以选择用函数返回值把参数的所有权返回回来，如果有多个返回值，可以使用元组。

Rust针对这种操作引入了“引用”功能来防止这种笨拙的写法。

# 引用与借用

## 引用

“&”表示引用语义，用于在不获取所有权时使用值。

“&mut”表示可变引用，可以改变值。

对特定作用域中的特定数据来说，一次只能声明一个可变引用，这样是为了避免数据竞争。数据竞争会导致未定义行为。

当拥有变量的不可变引用时，不能同时取得可变引用。

## 悬垂引用 | 悬垂指针

指的是，指针指向这块内存，但是这块内存已经被释放另作他用了。

Rust通过保证数据一定能活过引用（引用一定死在数据前面）来排除悬垂引用。

# 切片

## 字符串切片

写作：

```rust
let s = String::from("hello world");
let hello = &s[0..5];
```

“..”左右的数字代表索引（依旧是左闭右开），可以省略，省略则自动当成第一个或最后一个。

字符串切片的类型写作`&str`，就是字符串字面量。

## 其它类型切片

```rust
let a = [1,2,3,4,5];
let slice = &a[1..3];
```

这里slice的类型是`&[i32]`。